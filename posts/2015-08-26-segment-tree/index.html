<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Segment Tree | 自由研究帳</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://kiripon.net/css/main.min.975b1911c008aee6ab5fb42e51274b8268ebcb65dc15bd4a5f69b9eedb485c3e.css><link type=text/css rel=stylesheet href=/css/custom.css><script>MathJax={loader:{load:['[tex]/amscd']},tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:true,tags:'ams',macros:{ssqrt:['\\sqrt{\\smash[b]{\\mathstrut #1}}',1],tcdegree:['\\unicode{xb0}'],tccelsius:['\\unicode{x2103}'],tcperthousand:['\\unicode{x2030}'],tcmu:['\\unicode{x3bc}'],tcohm:['\\unicode{x3a9}']},packages:{'[+]':['amsCd']}},chtml:{matchFontHeight:false,displayAlign:"left",displayIndent:"2em"}};</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body><nav><header><div class=site-title><a href=/>自由研究帳</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/about/>About</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=/archives/>Archives</a>
<a class="color-link nav-link" href=https://kiripon.net/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://kiripon.net/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Segment Tree</h1><time>August 26, 2014</time><div><p><h1 id=segment-tree>Segment Tree</h1><ul><li>モノイド $(M,\ast,e)$</li><li>$a_1,..,a_n \in M$</li></ul><p>に対して,以下のことがそれぞれ $O(log(n))$ で行えるデータ構造</p><ul><li>$a_i \ast a_{i+1} \ast \dots \ast a_k$ を求める</li><li>$a_i$ の書き換え</li></ul><h1 id=verification>Verification</h1><p>AOJを用いて実装の正しさを確認した.</p><ul><li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A">DSL-2-A Range Minimum Query</a></li><li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B">DSL-2-B Range Sum Query</a></li></ul><h1 id=実装>実装</h1><p>Segment Tree は配列を使った破壊的な実装がよく知られている。
しかし今回はHaskellで実装をおこなうために、副作用を用いない永続データ
構造として実装した。</p><h2 id=コード>コード</h2><p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B">Range Sum Query</a> でverifyしたときのものを載せる</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=cm>{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}</span>
<span class=cm>{-# LANGUAGE BangPatterns #-}</span>
<span class=cm>{-# LANGUAGE ViewPatterns #-}</span>
<span class=cm>{-# LANGUAGE UnboxedTuples #-}</span>
<span class=kr>module</span> <span class=nn>Main</span> <span class=p>(</span><span class=nf>main</span><span class=p>)</span> <span class=kr>where</span>
<span class=kr>import</span> <span class=nn>Data.Int</span> <span class=p>(</span><span class=kt>Int32</span><span class=p>)</span>
<span class=kr>import</span> <span class=nn>Control.Monad</span>
<span class=kr>import</span> <span class=nn>Control.Applicative</span>
<span class=kr>import</span> <span class=nn>Data.Monoid</span>
<span class=kr>import</span> <span class=nn>Data.Maybe</span> <span class=p>(</span><span class=nf>fromJust</span><span class=p>)</span>
<span class=kr>import</span> <span class=k>qualified</span> <span class=nn>Data.ByteString.Char8</span> <span class=k>as</span> <span class=n>B8</span>
<span class=nf>getInts</span> <span class=ow>::</span> <span class=kt>IO</span> <span class=p>[</span><span class=kt>Int</span><span class=p>]</span>
<span class=nf>getInts</span> <span class=ow>=</span>  <span class=n>map</span> <span class=p>(</span><span class=n>fst</span> <span class=o>.</span> <span class=n>fromJust</span> <span class=o>.</span> <span class=kt>B8</span><span class=o>.</span><span class=n>readInt</span><span class=p>)</span> <span class=o>.</span> <span class=kt>B8</span><span class=o>.</span><span class=n>words</span> <span class=o>&lt;$&gt;</span> <span class=kt>B8</span><span class=o>.</span><span class=n>getLine</span>

<span class=nf>main</span> <span class=ow>::</span> <span class=kt>IO</span> <span class=nb>()</span>
<span class=nf>main</span> <span class=ow>=</span> <span class=kr>do</span>
  <span class=n>n</span><span class=kt>:</span><span class=n>q</span><span class=kt>:</span><span class=kr>_</span> <span class=ow>&lt;-</span> <span class=n>getInts</span>
  <span class=kr>let</span> <span class=n>bst</span> <span class=ow>=</span> <span class=n>fromList</span> <span class=o>$</span> <span class=n>replicate</span> <span class=n>n</span> <span class=n>mempty</span> <span class=ow>::</span> <span class=kt>STree</span> <span class=p>(</span><span class=kt>Sum</span> <span class=kt>Int</span><span class=p>)</span>
  <span class=n>loop</span> <span class=n>bst</span> <span class=n>q</span>
  <span class=n>return</span> <span class=nb>()</span>
  <span class=kr>where</span>
    <span class=n>loop</span> <span class=kr>_</span> <span class=mi>0</span> <span class=ow>=</span> <span class=n>return</span> <span class=nb>()</span>
    <span class=n>loop</span> <span class=o>!</span><span class=n>tree</span> <span class=o>!</span><span class=n>cnt</span> <span class=ow>=</span> <span class=kr>do</span>
      <span class=n>q</span><span class=err>❌</span><span class=n>y</span><span class=kt>:</span><span class=kr>_</span> <span class=ow>&lt;-</span> <span class=n>getInts</span>
      <span class=kr>if</span> <span class=n>q</span> <span class=o>==</span> <span class=mi>0</span>
        <span class=kr>then</span> <span class=kr>do</span>
        <span class=kr>let</span> <span class=n>tree&#39;</span> <span class=ow>=</span> <span class=n>update</span> <span class=p>(</span><span class=n>mappend</span> <span class=o>$</span> <span class=n>fromIntegral</span> <span class=n>y</span><span class=p>)</span> <span class=n>x</span> <span class=n>tree</span>
        <span class=n>loop</span> <span class=n>tree&#39;</span> <span class=p>(</span><span class=n>cnt</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
        <span class=kr>else</span> <span class=kr>do</span>
        <span class=n>print</span> <span class=o>.</span> <span class=n>getSum</span> <span class=o>$</span> <span class=n>query</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span> <span class=n>tree</span>
        <span class=n>loop</span> <span class=n>tree</span> <span class=p>(</span><span class=n>cnt</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>

<span class=c1>---------------------------------------------</span>
<span class=c1>--- Monoid instance for range minimum/maximum query</span>
<span class=kr>newtype</span> <span class=kt>Min</span> <span class=ow>=</span> <span class=kt>Min</span> <span class=p>{</span><span class=n>fromMin</span> <span class=ow>::</span> <span class=kt>Int32</span> <span class=p>}</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Ord</span><span class=p>,</span><span class=kt>Show</span><span class=p>,</span><span class=kt>Eq</span><span class=p>,</span><span class=kt>Read</span><span class=p>)</span>
<span class=kr>instance</span> <span class=kt>Monoid</span> <span class=kt>Min</span> <span class=kr>where</span>
  <span class=n>mempty</span> <span class=ow>=</span> <span class=kt>Min</span> <span class=n>maxBound</span>
  <span class=cm>{-# INLINE mempty #-}</span>
  <span class=n>mappend</span> <span class=ow>=</span> <span class=n>min</span>
  <span class=cm>{-# INLINE mappend #-}</span>

<span class=kr>newtype</span> <span class=kt>Max</span> <span class=ow>=</span> <span class=kt>Max</span> <span class=kt>Int</span> <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Ord</span><span class=p>,</span><span class=kt>Show</span><span class=p>,</span><span class=kt>Eq</span><span class=p>)</span>
<span class=kr>instance</span> <span class=kt>Monoid</span> <span class=kt>Max</span> <span class=kr>where</span>
  <span class=n>mempty</span> <span class=ow>=</span> <span class=kt>Max</span> <span class=n>minBound</span>
  <span class=cm>{-# INLINE mempty #-}</span>
  <span class=n>mappend</span> <span class=ow>=</span> <span class=n>max</span>
  <span class=cm>{-# INLINE mappend #-}</span>

<span class=c1>---------------------</span>
<span class=c1>--- Segment Tree</span>
<span class=kr>data</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>=</span> <span class=kt>Leaf</span> <span class=cm>{-# UNPACK #-}</span><span class=o>!</span><span class=kt>Int</span> <span class=o>!</span><span class=n>v</span>
             <span class=o>|</span> <span class=kt>Branch</span> <span class=cm>{-# UNPACK #-}</span><span class=o>!</span><span class=p>(</span><span class=kt>Int</span><span class=p>,</span><span class=kt>Int</span><span class=p>)</span> <span class=o>!</span><span class=n>v</span> <span class=o>!</span><span class=p>(</span><span class=kt>STree</span> <span class=n>v</span><span class=p>)</span> <span class=o>!</span><span class=p>(</span><span class=kt>STree</span> <span class=n>v</span><span class=p>)</span>
             <span class=kr>deriving</span> <span class=p>(</span><span class=kt>Show</span><span class=p>)</span>
<span class=c1>-- | make segment tree from [a_1 .. a_n] (1-based indexing)</span>
<span class=nf>fromList</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span> <span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
<span class=nf>fromList</span> <span class=o>!</span><span class=n>xs</span> <span class=ow>=</span> <span class=n>makeTree</span> <span class=p>(</span><span class=mi>1</span><span class=p>,(</span><span class=n>length</span> <span class=n>xs</span><span class=p>))</span> <span class=n>xs</span>
<span class=cm>{-# INLINE fromList #-}</span>

<span class=c1>-- | make segment tree from [a_k .. a_l]</span>
<span class=nf>makeTree</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=kt>Int</span><span class=p>,</span><span class=kt>Int</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
<span class=nf>makeTree</span> <span class=kr>_</span> <span class=o>!</span><span class=kt>[]</span> <span class=ow>=</span> <span class=ne>error</span> <span class=s>&#34;empty list&#34;</span>
<span class=nf>makeTree</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=n>l</span><span class=p>)</span> <span class=o>!</span><span class=n>es</span> <span class=ow>=</span> <span class=n>loop</span> <span class=o>$</span> <span class=n>map</span> <span class=p>(</span><span class=n>uncurry</span> <span class=n>f</span><span class=p>)</span> <span class=p>(</span><span class=n>zip</span> <span class=p>[</span><span class=n>k</span><span class=o>..</span><span class=n>l</span><span class=p>]</span> <span class=n>es</span><span class=p>)</span>
  <span class=kr>where</span>
    <span class=n>loop</span> <span class=o>!</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=ow>=</span> <span class=n>x</span>
    <span class=n>loop</span> <span class=o>!</span><span class=n>xs</span> <span class=ow>=</span> <span class=n>loop</span> <span class=o>$</span> <span class=n>buildTree</span> <span class=n>xs</span>
    <span class=n>f</span> <span class=ow>::</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
    <span class=n>f</span> <span class=o>!</span><span class=n>ix</span> <span class=o>!</span><span class=n>v</span> <span class=ow>=</span> <span class=kt>Leaf</span> <span class=n>ix</span> <span class=n>v</span>
    <span class=n>buildTree</span> <span class=o>!</span><span class=p>(</span><span class=n>a</span><span class=err>🅱</span><span class=n>ys</span><span class=p>)</span> <span class=ow>=</span> <span class=kr>let</span> <span class=n>v</span> <span class=ow>=</span> <span class=n>val</span> <span class=n>a</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>b</span>
                          <span class=kr>in</span> <span class=kt>Branch</span> <span class=p>(</span><span class=n>left</span> <span class=n>a</span><span class=p>,</span><span class=n>right</span> <span class=n>b</span><span class=p>)</span> <span class=n>v</span> <span class=n>a</span> <span class=n>b</span> <span class=kt>:</span> <span class=n>buildTree</span> <span class=n>ys</span>
    <span class=n>buildTree</span> <span class=o>!</span><span class=n>x</span> <span class=ow>=</span> <span class=n>x</span>

<span class=nf>range</span> <span class=ow>::</span> <span class=kt>STree</span> <span class=n>v</span><span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Int</span><span class=p>,</span><span class=kt>Int</span><span class=p>)</span>
<span class=nf>range</span> <span class=o>!</span><span class=p>(</span><span class=kt>Leaf</span> <span class=n>r</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>r</span><span class=p>,</span><span class=n>r</span><span class=p>)</span>
<span class=nf>range</span> <span class=o>!</span><span class=p>(</span><span class=kt>Branch</span> <span class=n>r</span> <span class=kr>_</span> <span class=kr>_</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=n>r</span>
<span class=cm>{-# INLINE range #-}</span>

<span class=nf>val</span> <span class=ow>::</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=n>v</span>
<span class=nf>val</span> <span class=o>!</span><span class=p>(</span><span class=kt>Leaf</span> <span class=kr>_</span> <span class=n>v</span><span class=p>)</span> <span class=ow>=</span> <span class=n>v</span>
<span class=nf>val</span> <span class=o>!</span><span class=p>(</span><span class=kt>Branch</span> <span class=kr>_</span> <span class=n>v</span> <span class=kr>_</span> <span class=kr>_</span><span class=p>)</span> <span class=ow>=</span> <span class=n>v</span>
<span class=cm>{-# INLINE val #-}</span>

<span class=nf>left</span><span class=p>,</span><span class=n>right</span> <span class=ow>::</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>Int</span>
<span class=nf>left</span> <span class=p>(</span><span class=kt>Main</span><span class=o>.</span><span class=n>range</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>l</span><span class=p>,</span><span class=kr>_</span><span class=p>))</span>  <span class=ow>=</span> <span class=n>l</span>
<span class=nf>right</span> <span class=p>(</span><span class=kt>Main</span><span class=o>.</span><span class=n>range</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kr>_</span><span class=p>,</span><span class=n>r</span><span class=p>))</span> <span class=ow>=</span> <span class=n>r</span>
<span class=cm>{-#INLINE left  #-}</span>
<span class=cm>{-#INLINE right #-}</span>

<span class=c1>-- | @query (l,r) t@ calculates @a_i &lt;&gt; .. &lt;&gt; a_r@. (@(&lt;&gt;)@ is equal to @mappend@)</span>
<span class=c1>-- O(log(n))</span>
<span class=nf>query</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span>  <span class=p>(</span><span class=kt>Int</span><span class=p>,</span> <span class=kt>Int</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=n>v</span>
<span class=nf>query</span> <span class=p>(</span><span class=n>ls</span><span class=p>,</span><span class=n>rs</span><span class=p>)</span> <span class=n>t</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>t</span>
  <span class=kr>where</span>
    <span class=n>loop</span> <span class=p>(</span><span class=kt>Leaf</span> <span class=n>ix</span> <span class=n>v</span><span class=p>)</span>
      <span class=ow>=</span> <span class=kr>if</span> <span class=n>ls</span> <span class=o>&lt;=</span> <span class=n>ix</span> <span class=o>&amp;&amp;</span> <span class=n>ix</span> <span class=o>&lt;=</span> <span class=n>rs</span> <span class=kr>then</span> <span class=n>v</span> <span class=kr>else</span> <span class=n>mempty</span>
    <span class=n>loop</span> <span class=p>(</span><span class=kt>Branch</span> <span class=p>(</span><span class=n>leftist</span><span class=p>,</span><span class=n>rightist</span><span class=p>)</span> <span class=n>v</span> <span class=n>lt</span> <span class=n>rt</span><span class=p>)</span>
      <span class=o>|</span> <span class=n>rightist</span> <span class=o>&lt;</span> <span class=n>ls</span> <span class=o>||</span> <span class=n>rs</span> <span class=o>&lt;</span> <span class=n>leftist</span> <span class=ow>=</span> <span class=n>mempty</span>
      <span class=o>|</span> <span class=n>ls</span> <span class=o>&lt;=</span> <span class=n>leftist</span> <span class=o>&amp;&amp;</span> <span class=n>rightist</span> <span class=o>&lt;=</span> <span class=n>rs</span> <span class=ow>=</span> <span class=n>v</span>
       <span class=o>|</span> <span class=n>otherwise</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>lt</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>loop</span> <span class=n>rt</span>
<span class=cm>{-# SPECIALIZE query :: (Int,Int) -&gt; STree (Sum Int) -&gt; Sum Int #-}</span>

<span class=c1>-- | @update f ix tree@ makes tree whose @ix@-th element is updated by @f@.</span>
<span class=c1>-- O(log(n))</span>
<span class=nf>update</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span> <span class=p>(</span><span class=n>v</span> <span class=ow>-&gt;</span> <span class=n>v</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
<span class=nf>update</span> <span class=n>f</span> <span class=o>!</span><span class=n>ix</span> <span class=o>!</span><span class=n>tree</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>tree</span>
  <span class=kr>where</span> <span class=n>loop</span> <span class=n>t</span> <span class=ow>=</span> <span class=kr>case</span> <span class=n>t</span> <span class=kr>of</span>
          <span class=kt>Leaf</span> <span class=n>i</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kr>if</span> <span class=n>ix</span> <span class=o>==</span> <span class=n>i</span>
                      <span class=kr>then</span> <span class=kt>Leaf</span> <span class=n>i</span> <span class=p>(</span><span class=n>f</span> <span class=n>v</span><span class=p>)</span>
                      <span class=kr>else</span> <span class=n>tree</span>
          <span class=kt>Branch</span> <span class=n>rng</span> <span class=kr>_</span> <span class=n>l</span><span class=o>@</span><span class=p>(</span><span class=kt>Main</span><span class=o>.</span><span class=n>range</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>ll</span><span class=p>,</span><span class=n>lr</span><span class=p>))</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>ll</span> <span class=o>&lt;=</span> <span class=n>ix</span> <span class=o>&amp;&amp;</span> <span class=n>ix</span> <span class=o>&lt;=</span> <span class=n>lr</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>l&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>l</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l&#39;</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r</span><span class=p>)</span> <span class=n>l&#39;</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>otherwise</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>r&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>r</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r&#39;</span><span class=p>)</span> <span class=n>l</span> <span class=n>r&#39;</span>
<span class=c1>-- | @add v ix tree@ is equal to @update (mappend v) ix tree.@</span>
<span class=nf>add</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
<span class=nf>add</span> <span class=o>!</span><span class=n>v</span> <span class=o>!</span><span class=n>ix</span> <span class=o>!</span><span class=n>tree</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>tree</span>
  <span class=kr>where</span> <span class=n>loop</span> <span class=n>t</span> <span class=ow>=</span> <span class=kr>case</span> <span class=n>t</span> <span class=kr>of</span>
          <span class=kt>Leaf</span> <span class=n>i</span> <span class=n>v0</span> <span class=ow>-&gt;</span> <span class=kr>if</span> <span class=n>ix</span> <span class=o>==</span> <span class=n>i</span>
                      <span class=kr>then</span> <span class=kt>Leaf</span> <span class=n>i</span> <span class=p>(</span><span class=n>v</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>v0</span><span class=p>)</span>
                      <span class=kr>else</span> <span class=n>tree</span>
          <span class=kt>Branch</span> <span class=n>rng</span> <span class=kr>_</span> <span class=n>l</span><span class=o>@</span><span class=p>(</span><span class=kt>Main</span><span class=o>.</span><span class=n>range</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>ll</span><span class=p>,</span><span class=n>lr</span><span class=p>))</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>ll</span> <span class=o>&lt;=</span> <span class=n>ix</span> <span class=o>&amp;&amp;</span> <span class=n>ix</span> <span class=o>&lt;=</span> <span class=n>lr</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>l&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>l</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l&#39;</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r</span><span class=p>)</span> <span class=n>l&#39;</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>otherwise</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>r&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>r</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r&#39;</span><span class=p>)</span> <span class=n>l</span> <span class=n>r&#39;</span>

<span class=c1>-- | @insert ix v tree@ makes tree whose @ix@-th element is replaced by @v@.</span>
<span class=c1>-- O(log(n))</span>
<span class=nf>insert</span> <span class=ow>::</span> <span class=kt>Monoid</span> <span class=n>v</span> <span class=ow>=&gt;</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span> <span class=ow>-&gt;</span> <span class=kt>STree</span> <span class=n>v</span>
<span class=nf>insert</span> <span class=o>!</span><span class=n>ix</span> <span class=o>!</span><span class=n>v</span> <span class=o>!</span><span class=n>tree</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>tree</span>
  <span class=kr>where</span> <span class=n>loop</span> <span class=n>t</span> <span class=ow>=</span> <span class=kr>case</span> <span class=n>t</span> <span class=kr>of</span>
          <span class=kt>Leaf</span> <span class=n>i</span> <span class=kr>_</span> <span class=ow>-&gt;</span> <span class=kr>if</span> <span class=n>ix</span> <span class=o>==</span> <span class=n>i</span>
                      <span class=kr>then</span> <span class=kt>Leaf</span> <span class=n>i</span> <span class=n>v</span>
                      <span class=kr>else</span> <span class=n>tree</span>
          <span class=kt>Branch</span> <span class=n>rng</span> <span class=kr>_</span> <span class=n>l</span><span class=o>@</span><span class=p>(</span><span class=kt>Main</span><span class=o>.</span><span class=n>range</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>ll</span><span class=p>,</span><span class=n>lr</span><span class=p>))</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>ll</span> <span class=o>&lt;=</span> <span class=n>ix</span> <span class=o>&amp;&amp;</span> <span class=n>ix</span> <span class=o>&lt;=</span> <span class=n>lr</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>l&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>l</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l&#39;</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r</span><span class=p>)</span> <span class=n>l&#39;</span> <span class=n>r</span>
            <span class=o>|</span> <span class=n>otherwise</span>
              <span class=ow>-&gt;</span> <span class=kr>let</span> <span class=n>r&#39;</span> <span class=ow>=</span> <span class=n>loop</span> <span class=n>r</span>
                 <span class=kr>in</span> <span class=kt>Branch</span> <span class=n>rng</span> <span class=p>(</span><span class=n>val</span> <span class=n>l</span> <span class=p>`</span><span class=n>mappend</span><span class=p>`</span> <span class=n>val</span> <span class=n>r&#39;</span><span class=p>)</span> <span class=n>l</span> <span class=n>r&#39;</span>
</code></pre></div><h1 id=補足>補足</h1><p>仮定をモノイドから群に強めることで, 実装がより単純なデータ構造である
Binary indexed tree を作ることができる.</p></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/haskell>#Haskell</a></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://kiripon.net/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww=" crossorigin=anonymous></script></footer></body></html>