<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Type safe Formatting | 自由研究帳</title><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#ff3db4><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://kiripon.net/css/main.min.975b1911c008aee6ab5fb42e51274b8268ebcb65dc15bd4a5f69b9eedb485c3e.css><link type=text/css rel=stylesheet href=/css/custom.css><script>MathJax={loader:{load:['[tex]/amscd']},tex:{inlineMath:[['$','$'],['\\(','\\)']],processEscapes:true,tags:'ams',macros:{ssqrt:['\\sqrt{\\smash[b]{\\mathstrut #1}}',1],tcdegree:['\\unicode{xb0}'],tccelsius:['\\unicode{x2103}'],tcperthousand:['\\unicode{x2030}'],tcmu:['\\unicode{x3bc}'],tcohm:['\\unicode{x3a9}']},packages:{'[+]':['amsCd']}},chtml:{matchFontHeight:false,displayAlign:"left",displayIndent:"2em"}};</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-56315243-1','auto');ga('send','pageview');}</script></head><body><nav><header><div class=site-title><a href=/>自由研究帳</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/about/>About</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=/archives/>Archives</a>
<a class="color-link nav-link" href=https://kiripon.net/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons></div><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://kiripon.net/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww=" crossorigin=anonymous></script></footer></nav><div id=content class=content-container><h1 class=post-title>Type safe Formatting</h1><time>October 5, 2014</time><div><p><h2 id=めも>めも</h2><p><a href=http://okmij.org/ftp/typed-formatting/>Type-safe functional formatted IO</a>
を読んだ際のメモ.型でラムダ式っぽい事ができるのは便利。gadtの証人の型を作るのに役立ちそう</p><h2 id=要約>要約</h2><p>printfやscanfのフォーマット文字列を実装する。OCamlのprintfのような特殊な型付をせず type safe なインターフェースを実装したい。
フォーマット文字列から型付けを行うのは無理なので(Template Haskellで頑張れば話は別)、DSLとして実装して適切な型がつくようにする。</p><p>最終的に次のように書けるようになる.</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=kr>let</span> <span class=n>hoge</span> <span class=ow>=</span> <span class=n>lit</span> <span class=s>&#34;PiyoPiyo &#34;</span> <span class=o>^</span> <span class=n>char</span> <span class=o>^</span> <span class=n>lit</span> <span class=s>&#34; fuga&#34;</span> <span class=o>^</span> <span class=n>int</span>
<span class=nf>result</span>  <span class=ow>=</span> <span class=n>sprintf</span> <span class=n>hoge</span> <span class=sc>&#39;a&#39;</span> <span class=mi>100</span>
<span class=c1>-- result == &#34;PiyoPiyo a 100&#34;</span>
<span class=cm>{-
</span><span class=cm>bad_result = sprintf hoge 300 &#39;a&#39;
</span><span class=cm>-- これは型エラー
</span><span class=cm>-}</span>
</code></pre></div><h2 id=the-initial-view>the initial view</h2><p>データ型<code>F a b</code>を考える。ここで、<code>F</code>は<code>F :: * -> * -> *</code>、つまり2引数の型コンストラクタ。
ここで型変数<code>b</code>は型変数<code>a</code>の1回以上の出現を含む型だとすると、Fは型レベルのラムダ式とみなせる。
この関数に引数を適用するにはFの第1引数<code>a</code>を適用したい型<code>x</code>でunifyしてやればよい。
すると<code>b</code>の中の<code>a</code>の出現が<code>x</code>で置き換えられ,関数適用の結果になる。
これはPrologでのラムダ式の挙動をエミュレートしているらしい。</p><div class=highlight><pre class=chroma><code class=language-haskell data-lang=haskell><span class=c1>-- F a b を型での関数抽象,つまり(λa. b)とみなす</span>
<span class=c1>-- 型レベルid</span>
<span class=nf>x</span> <span class=ow>=</span> <span class=n>lit</span> <span class=s>&#34;hoge&#34;</span> <span class=ow>::</span> <span class=kt>F</span> <span class=n>a</span> <span class=n>a</span>

<span class=c1>-- a の先頭に(Int -&gt;)を付け加える演算</span>
<span class=nf>y</span> <span class=ow>=</span> <span class=n>int</span> <span class=mi>10</span>     <span class=ow>::</span> <span class=kt>F</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>

<span class=c1>-- a の先頭に(Char -&gt;)を付け加える演算</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=n>char</span> <span class=sc>&#39;c&#39;</span>   <span class=ow>::</span> <span class=kt>F</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Char</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>

<span class=c1>-- &#34;p ^ q&#34; はpの型関数にqの型関数を適用することを表す。ラムダ式でいう簡約</span>
<span class=p>(</span><span class=o>^</span><span class=p>)</span> <span class=ow>::</span> <span class=kt>F</span> <span class=n>b</span> <span class=n>c</span> <span class=ow>-&gt;</span> <span class=kt>F</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>-&gt;</span> <span class=kt>F</span> <span class=n>a</span> <span class=n>c</span>

<span class=c1>-- このとき、x^yとy^zはそれぞれ次のような型になる。</span>
<span class=nf>x</span> <span class=o>^</span> <span class=n>y</span> <span class=ow>::</span> <span class=kt>F</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>)</span>
<span class=nf>y</span> <span class=o>^</span> <span class=n>z</span> <span class=ow>::</span> <span class=kt>F</span> <span class=n>a</span> <span class=p>(</span><span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Char</span> <span class=ow>-&gt;</span> <span class=n>a</span><span class=p>))</span>
</code></pre></div><h2 id=型が決まるまでの流れ記法は適当>型が決まるまでの流れ(記法は適当)</h2><pre><code>x ^ y ::
(F b c -&gt; F a b -&gt; F a c) (F a a) (F a (Int -&gt; a))
= (\@b1 @c1 =&gt; (F a1 b1) -&gt; F a1 c1) @a @a (F a (Int -&gt; a))
= ((F a1 a) -&gt; (F a1 a)) (F a (Int -&gt; a))
= \@k1 @k2 -&gt; (F k1 k2) $ @a @(Int-&gt;a)
= F a (Int -&gt; a)
</code></pre><pre><code>y^z :: (F b c -&gt; F a b -&gt; F a c) (F a (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F a1 t1 -&gt; F a1 t2) @a @(Char -&gt; a) (F a (Int -&gt; a))
= (F a1 a -&gt; F a1 (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F t1 (Char -&gt; t2)) @a @(Int -&gt; a)
= F a (Char -&gt; Int -&gt; a)
</code></pre><h2 id=final-view>final view</h2><p>initial viewの双対(数学的な意味での双対じゃないっぽい？)。
initial viewではデータ型として宣言していたEDSLだったが、ここでは関数として書いている。
ユーザーからは与えられたコンビネータを使っている限り違いを意識できない。
こっちはデータ型を作らないでその場で結果を構築する。</p><p>Initial viewからFinal viewは自動変換が可能らしい。</p><h2 id=その他>その他</h2><p>Template haskellであれこれしたり、といった話が続く。</p><h2 id=あとで読みたい>あとで読みたい</h2><ul><li><a href=http://www.brics.dk/RS/98/12/BRICS-RS-98-12.pdf>Functional unparsing</a></li><li><a href=http://pllab.is.ocha.ac.jp/~asai/papers/tr08-2.pdf>On Typing Delimited Continuations:Three New Solutions to the Printf Problem</a></li><li><a href=http://www.cs.ox.ac.uk/ralf.hinze/publications/Format.ps.gz>Formatting: a class act</a></li></ul><h2 id=参考にしたもの>参考にしたもの</h2><ul><li><a href=http://www.math.nagoya-u.ac.jp/~garrigue/papers/mlmt.pdf>More Logic More Types</a></li></ul><h2 id=メモ>メモ</h2><ul><li>sprintf は polyvariadic .. 任意の個数の任意の型を持った引数をとれる。</li><li>sscanf は partial function .. 引数によっては結果が無い関数になる</li></ul></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/haskell>#Haskell</a></div></div><footer class=footer-mobile><div class=social-icons></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://kiripon.net/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww=" crossorigin=anonymous></script></footer></body></html>