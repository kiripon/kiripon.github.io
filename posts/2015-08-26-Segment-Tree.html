<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>自由研究帳 - Segment Tree</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
	  <script type="text/javascript" src="//typesquare.com/accessor/script/typesquare.js?3gh7POzSj-0%3D" charset="utf-8"></script>
	  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56315243-1', 'auto');
  ga('send', 'pageview');

</script>

  </head>
  <body>
    <div id="header">
  <div id="logo">
    <a href="../index.html">自由研究帳</a>
  </div>
  <div id="navigation">
    <a href="./index.html">HOME</a>
    <a href="./profile.html">ABOUT</a>
    <a href="./contact.html">CONTACT</a>
    <a href="./archive.html">ARCHIVE</a>
  </div>
</div>

    <div id="content">
      <h1>Segment Tree</h1>
      <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on August 26, 2015
    
</div>
<div class="info">
  
  Tags: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/Data%20Structures.html">Data Structures</a>
  
</div>

<h2 id="segment-tree">Segment Tree</h2>
<ul>
<li>モノイド <span class="math inline">\((M,\ast,e)\)</span></li>
<li><span class="math inline">\(a_1,..,a_n \in M\)</span></li>
</ul>
<p>に対して,以下のことがそれぞれ <span class="math inline">\(O(log(n))\)</span> で行えるデータ構造</p>
<ul>
<li><span class="math inline">\(a_i \ast a_{i+1} \ast \dots \ast a_k\)</span> を求める</li>
<li><span class="math inline">\(a_i\)</span> の書き換え</li>
</ul>
<h2 id="verification">Verification</h2>
<p>AOJを用いて実装の正しさを確認した.</p>
<ul>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A">DSL-2-A Range Minimum Query</a></li>
<li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B">DSL-2-B Range Sum Query</a></li>
</ul>
<h2 id="実装">実装</h2>
<p>Segment Tree は配列を使った破壊的な実装がよく知られている。 しかし今回はHaskellで実装をおこなうために、副作用を用いない永続データ 構造として実装した。</p>
<h2 id="コード">コード</h2>
<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B">Range Sum Query</a> でverifyしたときのものを載せる</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}</span>
<span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">{-# LANGUAGE UnboxedTuples #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Data.Int</span> (<span class="dt">Int32</span>)
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromJust)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">B8</span>
<span class="ot">getInts ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
getInts <span class="fu">=</span>  map (fst <span class="fu">.</span> fromJust <span class="fu">.</span> B8.readInt) <span class="fu">.</span> B8.words <span class="fu">&lt;$&gt;</span> B8.getLine

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  n<span class="fu">:</span>q<span class="fu">:</span>_ <span class="ot">&lt;-</span> getInts
  <span class="kw">let</span> bst <span class="fu">=</span> fromList <span class="fu">$</span> replicate n<span class="ot"> mempty ::</span> <span class="dt">STree</span> (<span class="dt">Sum</span> <span class="dt">Int</span>)
  loop bst q
  return ()
  <span class="kw">where</span>
    loop _ <span class="dv">0</span> <span class="fu">=</span> return ()
    loop <span class="fu">!</span>tree <span class="fu">!</span>cnt <span class="fu">=</span> <span class="kw">do</span>
      q<span class="fu">:</span>x<span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">&lt;-</span> getInts
      <span class="kw">if</span> q <span class="fu">==</span> <span class="dv">0</span>
        <span class="kw">then</span> <span class="kw">do</span>
        <span class="kw">let</span> tree' <span class="fu">=</span> update (mappend <span class="fu">$</span> fromIntegral y) x tree
        loop tree' (cnt<span class="fu">-</span><span class="dv">1</span>)
        <span class="kw">else</span> <span class="kw">do</span>
        print <span class="fu">.</span> getSum <span class="fu">$</span> query (x,y) tree
        loop tree (cnt<span class="fu">-</span><span class="dv">1</span>)

<span class="fu">---------------------------------------------</span>
<span class="fu">---</span> <span class="dt">Monoid</span> <span class="kw">instance</span> for range minimum<span class="fu">/</span>maximum query
<span class="kw">newtype</span> <span class="dt">Min</span> <span class="fu">=</span> <span class="dt">Min</span> {<span class="ot">fromMin ::</span> <span class="dt">Int32</span> } <span class="kw">deriving</span> (<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Read</span>)
<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Min</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Min</span> maxBound
  <span class="ot">{-# INLINE mempty #-}</span>
  mappend <span class="fu">=</span> min
  <span class="ot">{-# INLINE mappend #-}</span>

<span class="kw">newtype</span> <span class="dt">Max</span> <span class="fu">=</span> <span class="dt">Max</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Eq</span>)
<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Max</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Max</span> minBound
  <span class="ot">{-# INLINE mempty #-}</span>
  mappend <span class="fu">=</span> max
  <span class="ot">{-# INLINE mappend #-}</span>

<span class="fu">---------------------</span>
<span class="fu">---</span> <span class="dt">Segment</span> <span class="dt">Tree</span>
<span class="kw">data</span> <span class="dt">STree</span> v <span class="fu">=</span> <span class="dt">Leaf</span> <span class="ot">{-# UNPACK #-}</span><span class="fu">!</span><span class="dt">Int</span> <span class="fu">!</span>v
             <span class="fu">|</span> <span class="dt">Branch</span> <span class="ot">{-# UNPACK #-}</span><span class="fu">!</span>(<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="fu">!</span>v <span class="fu">!</span>(<span class="dt">STree</span> v) <span class="fu">!</span>(<span class="dt">STree</span> v)
             <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="co">-- | make segment tree from [a_1 .. a_n] (1-based indexing)</span>
<span class="ot">fromList ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span> [v] <span class="ot">-&gt;</span> <span class="dt">STree</span> v
fromList <span class="fu">!</span>xs <span class="fu">=</span> makeTree (<span class="dv">1</span>,(length xs)) xs
<span class="ot">{-# INLINE fromList #-}</span>

<span class="co">-- | make segment tree from [a_k .. a_l]</span>
<span class="ot">makeTree ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> [v] <span class="ot">-&gt;</span> <span class="dt">STree</span> v
makeTree _ <span class="fu">!</span>[] <span class="fu">=</span> error <span class="st">&quot;empty list&quot;</span>
makeTree (k,l) <span class="fu">!</span>es <span class="fu">=</span> loop <span class="fu">$</span> map (uncurry f) (zip [k<span class="fu">..</span>l] es)
  <span class="kw">where</span>
    loop <span class="fu">!</span>[x] <span class="fu">=</span> x
    loop <span class="fu">!</span>xs <span class="fu">=</span> loop <span class="fu">$</span> buildTree xs
<span class="ot">    f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">STree</span> v
    f <span class="fu">!</span>ix <span class="fu">!</span>v <span class="fu">=</span> <span class="dt">Leaf</span> ix v
    buildTree <span class="fu">!</span>(a<span class="fu">:</span>b<span class="fu">:</span>ys) <span class="fu">=</span> <span class="kw">let</span> v <span class="fu">=</span> val a <span class="ot">`mappend`</span> val b
                          <span class="kw">in</span> <span class="dt">Branch</span> (left a,right b) v a b <span class="fu">:</span> buildTree ys
    buildTree <span class="fu">!</span>x <span class="fu">=</span> x

range<span class="ot"> ::</span> <span class="dt">STree</span> v<span class="ot">-&gt;</span> (<span class="dt">Int</span>,<span class="dt">Int</span>)
range <span class="fu">!</span>(<span class="dt">Leaf</span> r _) <span class="fu">=</span> (r,r)
range <span class="fu">!</span>(<span class="dt">Branch</span> r _ _ _) <span class="fu">=</span> r
<span class="ot">{-# INLINE range #-}</span>

<span class="ot">val ::</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> v
val <span class="fu">!</span>(<span class="dt">Leaf</span> _ v) <span class="fu">=</span> v
val <span class="fu">!</span>(<span class="dt">Branch</span> _ v _ _) <span class="fu">=</span> v
<span class="ot">{-# INLINE val #-}</span>

left,<span class="ot">right ::</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span>
left (Main.range <span class="ot">-&gt;</span> (l,_))  <span class="fu">=</span> l
right (Main.range <span class="ot">-&gt;</span> (_,r)) <span class="fu">=</span> r
<span class="ot">{-#INLINE left  #-}</span>
<span class="ot">{-#INLINE right #-}</span>

<span class="co">-- | @query (l,r) t@ calculates @a_i &lt;&gt; .. &lt;&gt; a_r@. (@(&lt;&gt;)@ is equal to @mappend@)</span>
<span class="co">-- O(log(n))</span>
<span class="ot">query ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span>  (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> v
query (ls,rs) t <span class="fu">=</span> loop t
  <span class="kw">where</span>
    loop (<span class="dt">Leaf</span> ix v)
      <span class="fu">=</span> <span class="kw">if</span> ls <span class="fu">&lt;=</span> ix <span class="fu">&amp;&amp;</span> ix <span class="fu">&lt;=</span> rs <span class="kw">then</span> v <span class="kw">else</span> mempty
    loop (<span class="dt">Branch</span> (leftist,rightist) v lt rt)
      <span class="fu">|</span> rightist <span class="fu">&lt;</span> ls <span class="fu">||</span> rs <span class="fu">&lt;</span> leftist <span class="fu">=</span> mempty
      <span class="fu">|</span> ls <span class="fu">&lt;=</span> leftist <span class="fu">&amp;&amp;</span> rightist <span class="fu">&lt;=</span> rs <span class="fu">=</span> v
       <span class="fu">|</span> otherwise <span class="fu">=</span> loop lt <span class="ot">`mappend`</span> loop rt
<span class="ot">{-# SPECIALIZE query :: (Int,Int) -&gt; STree (Sum Int) -&gt; Sum Int #-}</span>

<span class="co">-- | @update f ix tree@ makes tree whose @ix@-th element is updated by @f@.</span>
<span class="co">-- O(log(n))</span>
<span class="ot">update ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> <span class="dt">STree</span> v
update f <span class="fu">!</span>ix <span class="fu">!</span>tree <span class="fu">=</span> loop tree
  <span class="kw">where</span> loop t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
          <span class="dt">Leaf</span> i v <span class="ot">-&gt;</span> <span class="kw">if</span> ix <span class="fu">==</span> i
                      <span class="kw">then</span> <span class="dt">Leaf</span> i (f v)
                      <span class="kw">else</span> tree
          <span class="dt">Branch</span> rng _ l<span class="fu">@</span>(Main.range <span class="ot">-&gt;</span> (ll,lr)) r
            <span class="fu">|</span> ll <span class="fu">&lt;=</span> ix <span class="fu">&amp;&amp;</span> ix <span class="fu">&lt;=</span> lr
              <span class="ot">-&gt;</span> <span class="kw">let</span> l' <span class="fu">=</span> loop l
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l' <span class="ot">`mappend`</span> val r) l' r
            <span class="fu">|</span> otherwise
              <span class="ot">-&gt;</span> <span class="kw">let</span> r' <span class="fu">=</span> loop r
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l <span class="ot">`mappend`</span> val r') l r'
<span class="co">-- | @add v ix tree@ is equal to @update (mappend v) ix tree.@</span>
<span class="ot">add ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> <span class="dt">STree</span> v
add <span class="fu">!</span>v <span class="fu">!</span>ix <span class="fu">!</span>tree <span class="fu">=</span> loop tree
  <span class="kw">where</span> loop t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
          <span class="dt">Leaf</span> i v0 <span class="ot">-&gt;</span> <span class="kw">if</span> ix <span class="fu">==</span> i
                      <span class="kw">then</span> <span class="dt">Leaf</span> i (v <span class="ot">`mappend`</span> v0)
                      <span class="kw">else</span> tree
          <span class="dt">Branch</span> rng _ l<span class="fu">@</span>(Main.range <span class="ot">-&gt;</span> (ll,lr)) r
            <span class="fu">|</span> ll <span class="fu">&lt;=</span> ix <span class="fu">&amp;&amp;</span> ix <span class="fu">&lt;=</span> lr
              <span class="ot">-&gt;</span> <span class="kw">let</span> l' <span class="fu">=</span> loop l
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l' <span class="ot">`mappend`</span> val r) l' r
            <span class="fu">|</span> otherwise
              <span class="ot">-&gt;</span> <span class="kw">let</span> r' <span class="fu">=</span> loop r
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l <span class="ot">`mappend`</span> val r') l r'

<span class="co">-- | @insert ix v tree@ makes tree whose @ix@-th element is replaced by @v@.</span>
<span class="co">-- O(log(n))</span>
<span class="ot">insert ::</span> <span class="dt">Monoid</span> v <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">STree</span> v <span class="ot">-&gt;</span> <span class="dt">STree</span> v
insert <span class="fu">!</span>ix <span class="fu">!</span>v <span class="fu">!</span>tree <span class="fu">=</span> loop tree
  <span class="kw">where</span> loop t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
          <span class="dt">Leaf</span> i _ <span class="ot">-&gt;</span> <span class="kw">if</span> ix <span class="fu">==</span> i
                      <span class="kw">then</span> <span class="dt">Leaf</span> i v
                      <span class="kw">else</span> tree
          <span class="dt">Branch</span> rng _ l<span class="fu">@</span>(Main.range <span class="ot">-&gt;</span> (ll,lr)) r
            <span class="fu">|</span> ll <span class="fu">&lt;=</span> ix <span class="fu">&amp;&amp;</span> ix <span class="fu">&lt;=</span> lr
              <span class="ot">-&gt;</span> <span class="kw">let</span> l' <span class="fu">=</span> loop l
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l' <span class="ot">`mappend`</span> val r) l' r
            <span class="fu">|</span> otherwise
              <span class="ot">-&gt;</span> <span class="kw">let</span> r' <span class="fu">=</span> loop r
                 <span class="kw">in</span> <span class="dt">Branch</span> rng (val l <span class="ot">`mappend`</span> val r') l r'</code></pre></div>
<h2 id="補足">補足</h2>
<p>仮定をモノイドから群に強めることで, 実装がより単純なデータ構造である Binary indexed tree を作ることができる.</p>

<br>

<div id="disqus_thread"><div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  // required: replace example with your forum shortname
  var disqus_shortname = 'kiripon';
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  // required: replace example with your forum shortname
  var disqus_shortname = 'kiripon';
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
  var s = document.createElement('script'); s.async = true;
  s.type = 'text/javascript';
  s.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>

    </div>
    <div id="footer">
  <p>Copyright(C) 2013-2016, Kiripon</p>
  <p>Source code font is <a href="https://github.com/i-tu/Hasklig">Hasklig</a>,
    distributed under <a href="../texts/LICENSE.txt">OFL</a>.</p>
	<p>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
</div>

  </body>
</html>
