<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>自由研究帳 - Type safe Formatting</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<script type="text/javascript" src="//typesquare.com/accessor/script/typesquare.js?3gh7POzSj-0%3D" charset="utf-8"></script>
	
    </head>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-56315243-1', 'auto');
      ga('send', 'pageview');
    </script>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">自由研究帳</a>
            </div>
            <div id="navigation">
                <a href="../">HOME</a>
                <a href="../about.html">ABOUT</a>
                <a href="../contact.html">CONTACT</a>
                <a href="../archive.html">ARHCIVE</a>
            </div>
        </div>
        <div id="content">
            <h1>Type safe Formatting</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on October  5, 2014
    
</div>
<div class="info">
  
  Tags: <a href="../tags/Haskell.html">Haskell</a>, <a href="../tags/DSL.html">DSL</a>, <a href="../tags/GADT.html">GADT</a>
  
</div>

<h3 id="めも">めも</h3>
<p><a href="http://okmij.org/ftp/typed-formatting/">Type-safe functional formatted IO</a> を読んだ際のメモ.型でラムダ式っぽい事ができるのは便利。gadtの証人の型を作るのに役立ちそう</p>
<h3 id="要約">要約</h3>
<p>printfやscanfのフォーマット文字列を実装する。OCamlのprintfのような特殊な型付をせず type safe なインターフェースを実装したい。 フォーマット文字列から型付けを行うのは無理なので(Template Haskellで頑張れば話は別)、DSLとして実装して適切な型がつくようにする。</p>
<p>最終的に次のように書けるようになる.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> hoge <span class="fu">=</span> lit <span class="st">&quot;PiyoPiyo &quot;</span> <span class="fu">^</span> char <span class="fu">^</span> lit <span class="st">&quot; fuga&quot;</span> <span class="fu">^</span> int
result  <span class="fu">=</span> sprintf hoge <span class="ch">'a'</span> <span class="dv">100</span>
<span class="co">-- result == &quot;PiyoPiyo a 100&quot;</span>
<span class="co">{-</span>
<span class="co">bad_result = sprintf hoge 300 'a'</span>
<span class="co">-- これは型エラー</span>
<span class="co">-}</span></code></pre>
<h3 id="the-initial-view">the initial view</h3>
<p>データ型<code>F a b</code>を考える。ここで、<code>F</code>は<code>F :: * -&gt; * -&gt; *</code>、つまり2引数の型コンストラクタ。 ここで型変数<code>b</code>は型変数<code>a</code>の1回以上の出現を含む型だとすると、Fは型レベルのラムダ式とみなせる。 この関数に引数を適用するにはFの第1引数<code>a</code>を適用したい型<code>x</code>でunifyしてやればよい。 すると<code>b</code>の中の<code>a</code>の出現が<code>x</code>で置き換えられ,関数適用の結果になる。 これはPrologでのラムダ式の挙動をエミュレートしているらしい。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- F a b を型での関数抽象,つまり(λa. b)とみなす</span>
<span class="co">-- 型レベルid</span>
x <span class="fu">=</span> lit <span class="st">&quot;hoge&quot;</span><span class="ot"> ::</span> <span class="dt">F</span> a a

<span class="co">-- a の先頭に(Int -&gt;)を付け加える演算</span>
y <span class="fu">=</span> int <span class="dv">10</span><span class="ot">     ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)

<span class="co">-- a の先頭に(Char -&gt;)を付け加える演算</span>
z <span class="fu">=</span> char <span class="ch">'c'</span><span class="ot">   ::</span> <span class="dt">F</span> a (<span class="dt">Char</span> <span class="ot">-&gt;</span> a)

<span class="co">-- &quot;p ^ q&quot; はpの型関数にqの型関数を適用することを表す。ラムダ式でいう簡約</span>
<span class="ot">(^) ::</span> <span class="dt">F</span> b c <span class="ot">-&gt;</span> <span class="dt">F</span> a b <span class="ot">-&gt;</span> <span class="dt">F</span> a c

<span class="co">-- このとき、x^yとy^zはそれぞれ次のような型になる。</span>
x <span class="fu">^</span><span class="ot"> y ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)
y <span class="fu">^</span><span class="ot"> z ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> a))</code></pre>
<h3 id="型が決まるまでの流れ記法は適当">型が決まるまでの流れ(記法は適当)</h3>
<pre><code>x ^ y ::
(F b c -&gt; F a b -&gt; F a c) (F a a) (F a (Int -&gt; a))
= (\@b1 @c1 =&gt; (F a1 b1) -&gt; F a1 c1) @a @a (F a (Int -&gt; a))
= ((F a1 a) -&gt; (F a1 a)) (F a (Int -&gt; a))
= \@k1 @k2 -&gt; (F k1 k2) $ @a @(Int-&gt;a)
= F a (Int -&gt; a)</code></pre>
<pre><code>y^z :: (F b c -&gt; F a b -&gt; F a c) (F a (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F a1 t1 -&gt; F a1 t2) @a @(Char -&gt; a) (F a (Int -&gt; a))
= (F a1 a -&gt; F a1 (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F t1 (Char -&gt; t2)) @a @(Int -&gt; a)
= F a (Char -&gt; Int -&gt; a)</code></pre>
<h3 id="final-view">final view</h3>
<p>initial viewの双対(数学的な意味での双対じゃないっぽい？)。 initial viewではデータ型として宣言していたEDSLだったが、ここでは関数として書いている。 ユーザーからは与えられたコンビネータを使っている限り違いを意識できない。 こっちはデータ型を作らないでその場で結果を構築する。</p>
<p>Initial viewからFinal viewは自動変換が可能らしい。</p>
<h3 id="その他">その他</h3>
<p>Template haskellであれこれしたり、といった話が続く。</p>
<h3 id="あとで読みたい">あとで読みたい</h3>
<ul>
<li><a href="http://www.brics.dk/RS/98/12/BRICS-RS-98-12.pdf">Functional unparsing</a></li>
<li><a href="http://pllab.is.ocha.ac.jp/~asai/papers/tr08-2.pdf">On Typing Delimited Continuations:Three New Solutions to the Printf Problem</a></li>
<li><a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/Format.ps.gz">Formatting: a class act</a></li>
</ul>
<h3 id="参考にしたもの">参考にしたもの</h3>
<ul>
<li><a href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/mlmt.pdf">More Logic More Types</a></li>
</ul>
<h3 id="メモ">メモ</h3>
<ul>
<li>sprintf は polyvariadic .. 任意の個数の任意の型を持った引数をとれる。</li>
<li>sscanf は partial function .. 引数によっては結果が無い関数になる</li>
</ul>

<br>

<div id="disqus_thread"><div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  // required: replace example with your forum shortname
  var disqus_shortname = 'kiripon';
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  // required: replace example with your forum shortname
  var disqus_shortname = 'kiripon';
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
  var s = document.createElement('script'); s.async = true;
  s.type = 'text/javascript';
  s.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
</script>

        </div>
        <div id="footer">
	  <p>Copyright(C) 2013-2014, Kiripon</p>
	  <p>Source code font is <a href="https://github.com/i-tu/Hasklig">Hasklig</a>,distributed under <a href="../texts/LICENSE.txt">OFL</a>.</p>
	  <p>Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
        </div>
    </body>
</html>
