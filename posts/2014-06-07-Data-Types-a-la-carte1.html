<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>自由研究帳 - Data types a la carte のメモ</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<script type="text/javascript" src="//typesquare.com/accessor/script/typesquare.js?3gh7POzSj-0%3D" charset="utf-8"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">自由研究帳</a>
            </div>
            <div id="navigation">
                <a href="../">HOME</a>
                <a href="../about.html">ABOUT</a>
                <a href="../contact.html">CONTACT</a>
                <a href="../archive.html">ARHCIVE</a>
            </div>
        </div>

        <div id="content">
            <h1>Data types a la carte のメモ</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June  7, 2014
    
</div>
<div class="info">
  
  Tags: <a href="../tags/Haskell.html">Haskell</a>
  
</div>

<p>以下の論文を読んだ内容を自分なりにまとめたメモ. 文章は適当なので後で書き直すかもしれない.</p>
<ul>
<li><a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">Data Types a la carte</a></li>
</ul>
<h2 id="目標数式の木をつくる">目標：数式の木をつくる。</h2>
<p>数式の木をつくる。この時に木を直接書くのではなく、中置記法のコンストラクタをサポートしたり、さらに以下で述べるような３つの目標を満たすようなコンストラクタを作る。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- &lt;*&gt;　はapplicative functor の ap ではない</span>
<span class="co">--program1.hs--------</span>
arithTree1 <span class="fu">=</span> val <span class="dv">100</span> <span class="fu">&lt;*&gt;</span> val <span class="dv">3</span> <span class="fu">&lt;+&gt;</span> val <span class="dv">2</span> <span class="co">--変更前</span>
evalResult1 <span class="fu">=</span> eval arithTree <span class="co">-- evalResult == 302</span>
<span class="fu">---------------------</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--program2.hs---------</span>
arithTree2 <span class="fu">=</span> val <span class="dv">100</span> <span class="fu">&lt;*&gt;</span> val <span class="dv">3</span> <span class="fu">&lt;+&gt;</span> sqrt (val <span class="dv">4</span>) <span class="co">-- 変更後</span>
evalResult2 <span class="fu">=</span> eval arithTree <span class="co">-- evalResult == 302</span>
<span class="fu">----------------------</span></code></pre>
<p>設計の目標３つ</p>
<ol type="1">
<li>計算があとから追加できるようにする あとから log,rootなどの四則演算以外の項を追加できるようにする</li>
<li>あとから計算を追加したとしても、evalの(Add,Mod,Mul)の評価部分は変更する必要のないようにする</li>
<li><p>program1は掛け算、足し算だけだったものに、sqrtを使えるようにしたprogram2をつくった。 このときprogram1が動かなくなることのないようにする</p></li>
<li><h2>計算をあとから追加できるようにするには</h2></li>
</ol>
<p>組み立て可能なデータコンストラクタを定義する</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">BasicExpr</span> <span class="fu">=</span> (<span class="dt">Add</span> <span class="fu">:+:</span> <span class="dt">Val</span>)
<span class="kw">type</span> <span class="dt">NewExpr</span> <span class="fu">=</span> (<span class="dt">Add</span> <span class="fu">:+:</span> <span class="dt">Mul</span> <span class="fu">:+:</span> <span class="dt">Sqrt</span> <span class="fu">:+:</span> <span class="dt">Val</span>)</code></pre>
<ul>
<li>データコンストラクタを型のパラメータに取らせる</li>
<li>データコンストラクタを組み合わせられるようにする (<code>a :+: b</code>みたいに書けるようにする)</li>
</ul>
<p>DSLに新たにsqrtを追加すると、sqrtを表すデータコンストラクタが必要になる。 計算木に含まれるデータコンストラクタを組み込めるようにする。</p>
<h2 id="型コンストラクタの組み合わせ">1.1 型コンストラクタの組み合わせ</h2>
<p>型コンストラクタの直和を作る演算子<code>:+:</code>を用意する。 型パラメータeは後で説明するから今は気にしないでほしい</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Add</span> e <span class="fu">=</span> <span class="dt">A</span> e e
<span class="kw">data</span> <span class="dt">Mul</span> e <span class="fu">=</span> <span class="dt">M</span> e e
<span class="kw">data</span> <span class="dt">Val</span> e <span class="fu">=</span> <span class="dt">V</span> <span class="dt">Int</span>

<span class="kw">infixl</span> <span class="fu">:&lt;:</span> <span class="dv">7</span>
<span class="kw">data</span> (f <span class="fu">:+:</span> g) e <span class="fu">=</span> <span class="dt">Inl</span> (f e) <span class="fu">|</span> <span class="dt">Inr</span> (g e)</code></pre>
<h2 id="再帰型をつくるには">1.2 再帰型をつくるには？</h2>
<p><code>MyExpr = Add MyExpr MyExpr | Val Int</code> と同様の構造を作るとき、Addの子供にはMyExprが来てほしい。</p>
<p>再帰型を作るために型上の不動点演算子<code>Fix</code>を導入する。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</code></pre>
<p>これを使うと4 * 2を表す構文木は以下のように書ける</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eight ::</span> <span class="dt">Fix</span> (<span class="dt">Mul</span> <span class="fu">:+:</span> <span class="dt">Val</span>)
eight <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">Inl</span> (<span class="dt">Mul</span> (<span class="dt">Fix</span> (<span class="dt">Inr</span> (<span class="dt">Val</span> <span class="dv">4</span>))) (<span class="dt">Fix</span> (<span class="dt">Inr</span> (<span class="dt">Val</span> <span class="dv">2</span>)))))</code></pre>
<p>Fix,Inl,Inrを(心の中で)消して構造を見てみると、型の上で再帰構造になっているのがわかる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Mul</span> (<span class="dt">Val</span> <span class="dv">4</span>) (<span class="dt">Val</span> <span class="dv">2</span>)</code></pre>
<p>これで木構造が作れるようになった。</p>
<h2 id="スマートコンストラクタ1">スマートコンストラクタ(1)</h2>
<p>Inr とか Inl とか長ったらしくて書いてられない(あとFixも) 型から勝手に構造が決定されるコンストラクタをつくる。 こんな型をもったコンストラクタがあると嬉しい。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">val ::</span> (<span class="dt">Val</span> <span class="fu">:&lt;:</span> f, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> f
<span class="ot">(&lt;+&gt;) ::</span> (<span class="dt">Add</span> <span class="fu">:&lt;:</span> f, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Expr</span> f <span class="ot">-&gt;</span> <span class="dt">Expr</span> f <span class="ot">-&gt;</span> <span class="dt">Expr</span> f</code></pre>
<p>(ここで<code>Val :&lt;: f</code>は、[fにはValが含まれる]と読む)</p>
<p>つまり、完成した式の型に応じて自動的に適切な変換をするようなコンストラクタを作りたい。</p>
<p>型クラスをうまくつかってこれを実現する。</p>
<h2 id="スマートコンストラクタ2">スマートコンストラクタ(2)</h2>
<p>制約<code>sub :&lt;: sup</code>が与えられた時,<code>sub a</code>を<code>sup a</code>にキャストすることが可能になる。 キャスト可能なことを型クラスとインスタンスで表現すると以下のようになる</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (sub <span class="fu">:&lt;:</span> sup) <span class="kw">where</span>
<span class="ot">  inj ::</span> sub a <span class="ot">-&gt;</span> sup a

<span class="kw">instance</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> f <span class="kw">where</span>
  inj x <span class="fu">=</span> x <span class="co">-- 反射律</span>

<span class="kw">instance</span> (<span class="dt">Functor</span> f,<span class="dt">Functor</span> g) 
  <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> (f <span class="fu">:+:</span> g) <span class="kw">where</span>
  inj x <span class="fu">=</span> <span class="dt">Inl</span> x <span class="co">-- 左への埋め込み</span>

<span class="kw">instance</span> (<span class="dt">Functor</span> f,<span class="dt">Functor</span> g,<span class="dt">Functor</span> h,f <span class="fu">:&lt;:</span> h ) 
  <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> (g <span class="fu">:+:</span> h) <span class="kw">where</span>
  inj x <span class="fu">=</span> <span class="dt">Inr</span> (inj x) <span class="co">-- 右への埋め込み</span></code></pre>
<p>不動点をとった型に埋め込むには以下の関数<code>inject</code>を定義すればいい</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inject ::</span> (<span class="dt">Functor</span> f,<span class="dt">Functor</span> g,g <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> g (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f
inject <span class="fu">=</span> <span class="dt">Fix</span> <span class="fu">.</span> inj</code></pre>
<p>上記の<code>inject</code>を使ってコンストラクタを定義すると以下のようになる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">val ::</span> (<span class="dt">Val</span> <span class="fu">:&lt;:</span> f, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> f
val x <span class="fu">=</span> inject (<span class="dt">Val</span> x)

<span class="ot">(&lt;+&gt;) ::</span> (<span class="dt">Add</span> <span class="fu">:&lt;:</span> f, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Expr</span> f <span class="ot">-&gt;</span> <span class="dt">Expr</span> f <span class="ot">-&gt;</span> <span class="dt">Expr</span> f
x <span class="fu">&lt;+&gt;</span> y <span class="fu">=</span> inject (<span class="dt">Add</span> x y)</code></pre>
<p>スマートコンストラクタはこれで完成。この式を評価する方法はまた次回</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
