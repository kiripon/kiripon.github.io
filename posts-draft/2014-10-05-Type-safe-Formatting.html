<h2 id="めも">めも</h2>
<p><a href="http://okmij.org/ftp/typed-formatting/">Type-safe functional formatted IO</a> を読んだ際のメモ.型でラムダ式っぽい事ができるのは便利。gadtの証人の型を作るのに役立ちそう</p>
<h2 id="要約">要約</h2>
<p>printfやscanfのフォーマット文字列を実装する。OCamlのprintfのような特殊な型付をせず type safe なインターフェースを実装したい。 フォーマット文字列から型付けを行うのは無理なので(Template Haskellで頑張れば話は別)、DSLとして実装して適切な型がつくようにする。</p>
<p>最終的に次のように書けるようになる.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> hoge <span class="fu">=</span> lit <span class="st">&quot;PiyoPiyo &quot;</span> <span class="fu">^</span> char <span class="fu">^</span> lit <span class="st">&quot; fuga&quot;</span> <span class="fu">^</span> int
result  <span class="fu">=</span> sprintf hoge <span class="ch">&#39;a&#39;</span> <span class="dv">100</span>
<span class="co">-- result == &quot;PiyoPiyo a 100&quot;</span>
<span class="co">{-</span>
<span class="co">bad_result = sprintf hoge 300 &#39;a&#39;</span>
<span class="co">-- これは型エラー</span>
<span class="co">-}</span></code></pre>
<h2 id="the-initial-view">the initial view</h2>
<p>データ型<code>F a b</code>を考える。ここで、<code>F</code>は<code>F :: * -&gt; * -&gt; *</code>、つまり2引数の型コンストラクタ。 ここで型変数<code>b</code>は型変数<code>a</code>の1回以上の出現を含む型だとすると、Fは型レベルのラムダ式とみなせる。 この関数に引数を適用するにはFの第1引数<code>a</code>を適用したい型<code>x</code>でunifyしてやればよい。 すると<code>b</code>の中の<code>a</code>の出現が<code>x</code>で置き換えられ,関数適用の結果になる。 これはPrologでのラムダ式の挙動をエミュレートしているらしい。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- F a b を型での関数抽象,つまり(λa. b)とみなす</span>
<span class="co">-- 型レベルid</span>
x <span class="fu">=</span> lit <span class="st">&quot;hoge&quot;</span><span class="ot"> ::</span> <span class="dt">F</span> a a

<span class="co">-- a の先頭に(Int -&gt;)を付け加える演算</span>
y <span class="fu">=</span> int <span class="dv">10</span><span class="ot">     ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)

<span class="co">-- a の先頭に(Char -&gt;)を付け加える演算</span>
z <span class="fu">=</span> char <span class="ch">&#39;c&#39;</span><span class="ot">   ::</span> <span class="dt">F</span> a (<span class="dt">Char</span> <span class="ot">-&gt;</span> a)

<span class="co">-- &quot;p ^ q&quot; はpの型関数にqの型関数を適用することを表す。ラムダ式でいう簡約</span>
<span class="ot">(^) ::</span> <span class="dt">F</span> b c <span class="ot">-&gt;</span> <span class="dt">F</span> a b <span class="ot">-&gt;</span> <span class="dt">F</span> a c

<span class="co">-- このとき、x^yとy^zはそれぞれ次のような型になる。</span>
x <span class="fu">^</span><span class="ot"> y ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> a)
y <span class="fu">^</span><span class="ot"> z ::</span> <span class="dt">F</span> a (<span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> a))</code></pre>
<h2 id="型が決まるまでの流れ記法は適当">型が決まるまでの流れ(記法は適当)</h2>
<pre><code>x ^ y ::
(F b c -&gt; F a b -&gt; F a c) (F a a) (F a (Int -&gt; a))
= (\@b1 @c1 =&gt; (F a1 b1) -&gt; F a1 c1) @a @a (F a (Int -&gt; a))
= ((F a1 a) -&gt; (F a1 a)) (F a (Int -&gt; a))
= \@k1 @k2 -&gt; (F k1 k2) $ @a @(Int-&gt;a)
= F a (Int -&gt; a)</code></pre>
<pre><code>y^z :: (F b c -&gt; F a b -&gt; F a c) (F a (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F a1 t1 -&gt; F a1 t2) @a @(Char -&gt; a) (F a (Int -&gt; a))
= (F a1 a -&gt; F a1 (Char -&gt; a)) (F a (Int -&gt; a))
= \@t1 @t2 =&gt; (F t1 (Char -&gt; t2)) @a @(Int -&gt; a)
= F a (Char -&gt; Int -&gt; a)</code></pre>
<h2 id="final-view">final view</h2>
<p>initial viewの双対(数学的な意味での双対じゃないっぽい？)。 initial viewではデータ型として宣言していたEDSLだったが、ここでは関数として書いている。 ユーザーからは与えられたコンビネータを使っている限り違いを意識できない。 こっちはデータ型を作らないでその場で結果を構築する。</p>
<p>Initial viewからFinal viewは自動変換が可能らしい。</p>
<h2 id="その他">その他</h2>
<p>Template haskellであれこれしたり、といった話が続く。</p>
<h2 id="あとで読みたい">あとで読みたい</h2>
<ul>
<li><a href="http://www.brics.dk/RS/98/12/BRICS-RS-98-12.pdf">Functional unparsing</a></li>
<li><a href="http://pllab.is.ocha.ac.jp/~asai/papers/tr08-2.pdf">On Typing Delimited Continuations:Three New Solutions to the Printf Problem</a></li>
<li><a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/Format.ps.gz">Formatting: a class act</a></li>
</ul>
<h2 id="参考にしたもの">参考にしたもの</h2>
<ul>
<li><a href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/mlmt.pdf">More Logic More Types</a></li>
</ul>
<h2 id="メモ">メモ</h2>
<ul>
<li>sprintf は polyvariadic .. 任意の個数の任意の型を持った引数をとれる。</li>
<li>sscanf は partial function .. 引数によっては結果が無い関数になる</li>
</ul>